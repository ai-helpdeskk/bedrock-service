# .github/workflows/bedrock-service-cd.yml
name: Bedrock Service - CD

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
        - staging
        - production
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
  repository_dispatch:
    types: [deploy-bedrock-service]

env:
  SERVICE_NAME: bedrock-service
  IMAGE_NAME: samitsinghhh/bedrock-service
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || github.event.client_payload.environment || 'staging' }}
    
    steps:
      - name: Set deployment parameters
        id: params
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            ENVIRONMENT="${{ github.event.client_payload.environment }}"
            IMAGE_TAG="${{ github.event.client_payload.image_tag }}"
          else
            ENVIRONMENT="staging"
            IMAGE_TAG="latest"
          fi
          
          if [ "$ENVIRONMENT" = "production" ]; then
            NAMESPACE="bedrock-chat-v2"
          else
            NAMESPACE="bedrock-chat-staging"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "full_image=${{ env.IMAGE_NAME }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          echo "üöÄ Deployment Configuration:"
          echo "- Environment: $ENVIRONMENT"
          echo "- Namespace: $NAMESPACE"
          echo "- Image Tag: $IMAGE_TAG"
          echo "- Full Image: ${{ env.IMAGE_NAME }}:$IMAGE_TAG"

      - name: Checkout k8s manifests
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/k8s-manifests
          token: ${{ secrets.MANIFEST_REPO_TOKEN }}
          path: k8s-manifests

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          if [ -z "${{ env.KUBE_CONFIG_DATA }}" ]; then
            echo "‚ùå KUBE_CONFIG_DATA secret not found!"
            exit 1
          fi
          
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          chmod 600 kubeconfig
          
          # Test connection
          kubectl cluster-info --request-timeout=30s
          echo "‚úÖ Connected to Kubernetes cluster"

      - name: Update deployment manifest
        run: |
          cd k8s-manifests
          
          DEPLOYMENT_FILE=""
          POSSIBLE_PATHS=(
            "k8s/deployments/bedrock-service-deployment.yaml"
            "deployments/bedrock-service-deployment.yaml"
            "manifests/bedrock-service-deployment.yaml"
          )
          
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -f "$path" ]; then
              DEPLOYMENT_FILE="$path"
              echo "Found deployment file: $path"
              break
            fi
          done
          
          if [ -z "$DEPLOYMENT_FILE" ]; then
            echo "‚ùå Bedrock Service deployment file not found!"
            echo "Available files:"
            find . -name "*bedrock-service*.yaml" -type f || echo "No Bedrock Service files found"
            exit 1
          fi
          
          echo "üìù Updating image in $DEPLOYMENT_FILE"
          echo "From: $(grep -n "image:" "$DEPLOYMENT_FILE" | head -1)"
          
          # Update image tag
          sed -i "s|image: samitsinghhh/bedrock-service:.*|image: ${{ steps.params.outputs.full_image }}|g" "$DEPLOYMENT_FILE"
          
          echo "To: $(grep -n "image:" "$DEPLOYMENT_FILE" | head -1)"
          echo "‚úÖ Manifest updated successfully"

      - name: Create namespace
        run: |
          export KUBECONFIG=kubeconfig
          kubectl create namespace ${{ steps.params.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Namespace ready: ${{ steps.params.outputs.namespace }}"

      - name: Apply supporting resources
        run: |
          export KUBECONFIG=kubeconfig
          cd k8s-manifests
          
          # Apply Secrets (for AWS credentials)
          if [ -f "k8s/secrets/app-secrets.yaml" ]; then
            echo "üîê Applying App Secrets..."
            kubectl apply -f k8s/secrets/app-secrets.yaml -n ${{ steps.params.outputs.namespace }} || true
          fi
          
          # Apply ConfigMaps
          if [ -d "k8s/configmaps" ]; then
            echo "üìã Applying ConfigMaps..."
            kubectl apply -f k8s/configmaps/ -n ${{ steps.params.outputs.namespace }} || true
          fi
          
          # Apply Services
          echo "üåê Applying Bedrock Service..."
          kubectl apply -f k8s/services/bedrock-service-service.yaml -n ${{ steps.params.outputs.namespace }} || true

      - name: Verify AWS credentials
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîç Checking AWS credentials secret..."
          if kubectl get secret app-secrets -n ${{ steps.params.outputs.namespace }} > /dev/null 2>&1; then
            echo "‚úÖ AWS credentials secret exists"
            # Check if secret has required keys (without exposing values)
            if kubectl get secret app-secrets -n ${{ steps.params.outputs.namespace }} -o jsonpath='{.data}' | grep -q "AWS_ACCESS_KEY_ID"; then
              echo "‚úÖ AWS_ACCESS_KEY_ID found in secret"
            else
              echo "‚ö†Ô∏è AWS_ACCESS_KEY_ID missing from secret"
            fi
            if kubectl get secret app-secrets -n ${{ steps.params.outputs.namespace }} -o jsonpath='{.data}' | grep -q "AWS_SECRET_ACCESS_KEY"; then
              echo "‚úÖ AWS_SECRET_ACCESS_KEY found in secret"
            else
              echo "‚ö†Ô∏è AWS_SECRET_ACCESS_KEY missing from secret"
            fi
          else
            echo "‚ö†Ô∏è AWS credentials secret not found - service may fail to start"
          fi

      - name: Deploy Bedrock Service
        run: |
          export KUBECONFIG=kubeconfig
          cd k8s-manifests
          
          echo "üöÄ Deploying Bedrock Service..."
          
          DEPLOYMENT_FILE=""
          POSSIBLE_PATHS=(
            "k8s/deployments/bedrock-service-deployment.yaml"
            "deployments/bedrock-service-deployment.yaml"
            "manifests/bedrock-service-deployment.yaml"
          )
          
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -f "$path" ]; then
              DEPLOYMENT_FILE="$path"
              break
            fi
          done
          
          kubectl apply -f "$DEPLOYMENT_FILE" -n ${{ steps.params.outputs.namespace }}
          
          echo "‚è≥ Waiting for rollout to complete..."
          kubectl rollout status deployment/bedrock-service -n ${{ steps.params.outputs.namespace }} --timeout=300s

      - name: Verify deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîç Verifying deployment..."
          
          # Check deployment status
          kubectl get deployment bedrock-service -n ${{ steps.params.outputs.namespace }} -o wide
          
          # Check pods
          echo "=== Pod Status ==="
          kubectl get pods -l app=bedrock-service -n ${{ steps.params.outputs.namespace }} -o wide
          
          # Check service
          echo "=== Service Status ==="
          kubectl get service bedrock-service -n ${{ steps.params.outputs.namespace }} -o wide
          
          # Check if pods are ready
          kubectl wait --for=condition=ready pod -l app=bedrock-service -n ${{ steps.params.outputs.namespace }} --timeout=120s

      - name: Run health checks
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üè• Running health checks..."
          
          # Test health endpoint
          echo "Testing health endpoint..."
          if kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/bedrock-service -- wget -qO- --timeout=10 http://localhost:9000/health; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ö†Ô∏è Health check failed, checking logs..."
            kubectl logs -n ${{ steps.params.outputs.namespace }} deployment/bedrock-service --tail=20
            echo "‚ö†Ô∏è Continuing deployment despite health check failure..."
          fi

      - name: Test model availability
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "ü§ñ Testing model availability..."
          
          # Test models endpoint
          echo "Testing models endpoint..."
          if kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/bedrock-service -- wget -qO- --timeout=15 http://localhost:9000/models | grep -q "models"; then
            echo "‚úÖ Models endpoint accessible"
          else
            echo "‚ö†Ô∏è Models endpoint test failed"
            kubectl logs -n ${{ steps.params.outputs.namespace }} deployment/bedrock-service --tail=10
          fi

      - name: Run smoke tests
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üß™ Running smoke tests..."
          
          # Test root endpoint
          echo "Testing root endpoint..."
          kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/bedrock-service -- wget -qO- --timeout=10 http://localhost:9000/ > /dev/null
          
          echo "‚úÖ Smoke tests passed"

      - name: Deployment summary
        if: always()
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "## üöÄ Bedrock Service Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Service**: ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.params.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ steps.params.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ steps.params.outputs.full_image }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ **Deployment successful!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìä Deployment Status" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get pods -l app=bedrock-service -n ${{ steps.params.outputs.namespace }} >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment failed!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üîç Troubleshooting Info" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get events -n ${{ steps.params.outputs.namespace }} --sort-by='.lastTimestamp' | tail -10 >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi

  # Rollback capability
  rollback:
    name: Rollback (Manual)
    runs-on: ubuntu-latest
    if: failure() && github.event.inputs.environment
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          chmod 600 kubeconfig

      - name: Rollback deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          NAMESPACE="${{ github.event.inputs.environment == 'production' && 'bedrock-chat-v2' || 'bedrock-chat-staging' }}"
          
          echo "üîÑ Rolling back Bedrock Service deployment..."
          kubectl rollout undo deployment/bedrock-service -n $NAMESPACE
          
          echo "‚è≥ Waiting for rollback to complete..."
          kubectl rollout status deployment/bedrock-service -n $NAMESPACE --timeout=180s
          
          echo "‚úÖ Rollback completed"
